<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Probability Distribution Fitter - Clemente Gotelli</title>
    <link rel="icon" type="image/x-icon" href="../images/favicon.png">
    <link rel="stylesheet" href="../styles.css">

    <!-- JStat via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
    <!-- Chart.js via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* Reusing styles from equation-solver.html */
        .workspace {
            display: grid;
            grid-template-columns: 1fr;
            gap: 24px;
            margin-top: 24px;
        }

        @media (min-width: 768px) {
            .workspace {
                grid-template-columns: 1fr 1fr;
            }

            .preview-panel {
                grid-column: 1 / -1;
            }
        }

        .editor-panel,
        .preview-panel {
            background: #ffffff;
            border: 1px solid #e3e7ed;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04);
            display: flex;
            flex-direction: column;
        }

        .editor-panel h3,
        .preview-panel h3 {
            margin-top: 0;
            color: #2a2f45;
            font-size: 18px;
            margin-bottom: 16px;
        }

        textarea.data-input {
            width: 100%;
            height: 250px;
            padding: 12px;
            border: 1px solid #cfd7e3;
            border-radius: 8px;
            font-family: "Roboto Mono", monospace;
            font-size: 14px;
            box-sizing: border-box;
            margin-bottom: 10px;
            resize: vertical;
        }

        .chart-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            background-color: #f7f9fb;
            border: 1px solid #e3e7ed;
            border-radius: 8px;
            padding: 10px;
            overflow: hidden;
            position: relative;
        }

        .status-message {
            margin-top: 5px;
            font-size: 14px;
            min-height: 20px;
        }

        .status-error {
            color: #d32f2f;
            font-weight: 500;
        }

        .status-info {
            color: #0288d1;
        }

        .primary-btn {
            background: #0f6fff;
            color: #ffffff;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.1s ease;
            width: 100%;
            margin-top: 10px;
        }

        .primary-btn:hover {
            transform: translateY(-1px);
        }

        .primary-btn:disabled {
            background: #b0c4de;
            cursor: not-allowed;
            transform: none;
        }

        .options-group {
            margin-top: 10px;
            margin-bottom: 20px;
        }

        .options-header {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 14px;
            color: #444;
            display: flex;
            justify-content: space-between;
        }

        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #333;
            cursor: pointer;
        }

        .checkbox-label input {
            margin-right: 6px;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            margin-top: 10px;
        }

        .results-table th,
        .results-table td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }

        .results-table th {
            font-weight: 600;
            color: #555;
            background: #fafafa;
        }

        .rank-1 {
            background-color: #e8f5e9;
            font-weight: 600;
        }

        .selected-row {
            background-color: #e3f2fd !important;
            border-left: 4px solid #0f6fff;
        }

        .results-table tr {
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .results-table tr:hover {
            background-color: #f5f5f5;
        }

        .warning-box {
            background-color: #fff3e0;
            border: 1px solid #ffe0b2;
            color: #e65100;
            padding: 10px;
            border-radius: 8px;
            font-size: 13px;
            margin-top: 15px;
            display: none;
        }
    </style>
</head>

<body>
    <div class="top-right-nav">
        <a href="../news.html">News</a>
        <a href="../blog.html">Blog</a>
        <a href="../tools.html">Tools</a>
        <a href="../aboutme.html">About Me</a>
    </div>
    <div class="corner-name"><a href="../index.html">Clemente Gotelli</a></div>

    <div class="post-header">
        <img src="../images/normal.png" alt="Normal probabilities"
            style="width: 100%; height: 400px; object-fit: cover; object-position: center; border-radius: 20px 20px 20px 20px; margin-bottom: 40px;">
    </div>

    <div class="post-container">
        <div class="post-text">
            <h1>Probability Distribution Fitter</h1>
            <p>Paste your data (one number per line) to fit and compare probability distributions. Uses Maximum
                Likelihood Estimation (MLE) or Method of Moments to find the best fit.</p>

            <div class="workspace">
                <div class="editor-panel">
                    <h3>Data Input</h3>
                    <textarea id="data-input" class="data-input"
                        placeholder="Paste numeric data here...&#10;1.2&#10;3.5&#10;4.8..."></textarea>

                    <div id="status-area" class="status-message"></div>
                </div>

                <div class="editor-panel">
                    <h3>Distribution Selection</h3>
                    <div class="options-group">
                        <div class="options-header">
                            <span>Distributions</span>
                            <div>
                                <a href="#" id="select-all" style="font-size:12px; margin-right:8px;">All</a>
                                <a href="#" id="select-continuous"
                                    style="font-size:12px; margin-right:8px;">Continuous</a>
                                <a href="#" id="select-discrete" style="font-size:12px;">Discrete</a>
                            </div>
                        </div>
                        <div class="checkbox-grid">
                            <label class="checkbox-label" title="Continuous"><input type="checkbox"
                                    class="dist-opt continuous" value="normal" checked> Normal</label>
                            <label class="checkbox-label" title="Continuous"><input type="checkbox"
                                    class="dist-opt continuous" value="exponential" checked> Exponential</label>
                            <label class="checkbox-label" title="Continuous"><input type="checkbox"
                                    class="dist-opt continuous" value="uniform" checked> Uniform</label>
                            <label class="checkbox-label" title="Continuous"><input type="checkbox"
                                    class="dist-opt continuous" value="weibull"> Weibull</label>
                            <label class="checkbox-label" title="Continuous"><input type="checkbox"
                                    class="dist-opt continuous" value="gumbel"> Gumbel</label>
                            <label class="checkbox-label" title="Continuous, x > 0"><input type="checkbox"
                                    class="dist-opt continuous" value="lognormal"> Lognormal</label>
                            <label class="checkbox-label" title="Continuous, x > 0"><input type="checkbox"
                                    class="dist-opt continuous" value="gamma"> Gamma</label>
                            <label class="checkbox-label" title="Continuous, Extreme Value"><input type="checkbox"
                                    class="dist-opt continuous" value="gev"> GEV</label>
                            <label class="checkbox-label" title="Continuous, Heavy Tail"><input type="checkbox"
                                    class="dist-opt continuous" value="pareto"> Pareto</label>

                            <label class="checkbox-label" title="Discrete"><input type="checkbox"
                                    class="dist-opt discrete" value="poisson"> Poisson</label>
                            <label class="checkbox-label" title="Discrete, Overdispersed"><input type="checkbox"
                                    class="dist-opt discrete" value="negbin"> Neg. Binomial</label>
                            <label class="checkbox-label" title="Discrete, Bounded"><input type="checkbox"
                                    class="dist-opt discrete" value="binomial"> Binomial</label>
                        </div>
                    </div>

                    <button id="fit-btn" class="primary-btn">Fit Distributions</button>

                    <div id="results-area" style="margin-top: 20px; display: none;">
                        <h3>Ranking (AIC)</h3>
                        <table class="results-table">
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Distribution</th>
                                    <th title="Akaike Information Criterion">AIC</th>
                                    <th title="Delta AIC: Difference from best model">ΔAIC</th>
                                    <th title="Akaike Weight: Probability that this model is the best among the set">
                                        Weight</th>
                                </tr>
                            </thead>
                            <tbody id="results-body">
                            </tbody>
                        </table>

                        <div id="warnings-area" class="warning-box"></div>
                    </div>
                </div>

                <div class="preview-panel">
                    <h3>Visualization</h3>
                    <div
                        style="margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="bin-count" style="font-size: 13px; font-weight: 600; color: #444;">Number of
                                Bins:</label>
                            <input type="number" id="bin-count" value="" placeholder="Auto" min="2" max="100"
                                style="width: 60px; padding: 4px; border: 1px solid #cfd7e3; border-radius: 4px;">
                        </div>
                        <div style="display: flex; background: #e3e7ed; padding: 2px; border-radius: 6px;">
                            <button id="view-hist" class="view-btn active"
                                style="border:none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer; background: #fff; font-weight: 600; color: #0f6fff; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">Histogram</button>
                            <button id="view-qq" class="view-btn"
                                style="border:none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer; background: transparent; font-weight: 500; color: #555;">QQ
                                Plot</button>
                            <button id="view-stab" class="view-btn"
                                style="border:none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer; background: transparent; font-weight: 500; color: #555;">Stability</button>
                        </div>
                    </div>

                    <div id="qq-options" style="margin-bottom: 10px; display: none; justify-content: flex-end;">
                        <label class="checkbox-label" title="Focus on the largest 10% of values">
                            <input type="checkbox" id="upper-tail-only"> Upper tail only (top 10%)
                        </label>
                    </div>

                    <!-- Export Button Row -->
                    <div style="display: flex; justify-content: flex-end; margin-bottom: 10px; gap: 8px;">
                        <button id="export-btn"
                            style="background: #fff; border: 1px solid #cfd7e3; color: #555; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px;">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                            PNG
                        </button>
                        <button id="export-json"
                            style="background: #fff; border: 1px solid #cfd7e3; color: #555; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px;">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                                <line x1="16" y1="13" x2="8" y2="13"></line>
                                <line x1="16" y1="17" x2="8" y2="17"></line>
                                <polyline points="10 9 9 9 8 9"></polyline>
                            </svg>
                            JSON
                        </button>
                        <button id="export-csv"
                            style="background: #fff; border: 1px solid #cfd7e3; color: #555; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px;">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                                <line x1="12" y1="18" x2="12" y2="12"></line>
                                <line x1="9" y1="15" x2="15" y2="15"></line>
                            </svg>
                            CSV
                        </button>
                    </div>
                    <div class="chart-container">
                        <canvas id="fit-chart"></canvas>
                    </div>
                </div>

                <div id="diagnostics-panel"
                    style="margin-top: 15px; padding: 12px; background: #fafafa; border-radius: 6px; border: 1px solid #eee;">
                    <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #333;">Fit Diagnostics</h4>
                    <p id="diagnostics-text" style="margin: 0; font-size: 13px; color: #555; line-height: 1.4;">Select a
                        distribution to see diagnostics.</p>
                </div>

                <div id="insights-panel"
                    style="margin-top: 15px; padding: 12px; background: #e3f2fd; border-radius: 6px; border: 1px solid #bbdefb; display: none;">
                    <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #1565c0;">Data Insights</h4>
                    <ul id="insights-list"
                        style="margin: 0; padding-left: 20px; font-size: 13px; color: #0d47a1; line-height: 1.4;">
                    </ul>
                </div>

                <div id="params-output"
                    style="margin-top: 20px; font-family: monospace; font-size: 13px; white-space: pre-wrap; color: #333;">
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        window.addEventListener('load', () => {
            const dataInput = document.getElementById('data-input');
            const statusArea = document.getElementById('status-area');
            const fitBtn = document.getElementById('fit-btn');
            const resultsArea = document.getElementById('results-area');
            const resultsBody = document.getElementById('results-body');
            const paramsOutput = document.getElementById('params-output');
            const ctx = document.getElementById('fit-chart').getContext('2d');

            let chartInstance = null;

            // --- Helpers ---
            const parseData = (text) => {
                // Split by newline or comma
                const lines = text.split(/[\n,]+/);
                const data = [];
                let invalidCount = 0;
                for (let line of lines) {
                    line = line.trim();
                    if (line === '') continue;
                    const num = Number(line);
                    if (!isNaN(num)) {
                        data.push(num);
                    } else {
                        invalidCount++;
                    }
                }
                return { data, invalidCount };
            };

            const validateInput = () => {
                const { data, invalidCount } = parseData(dataInput.value);
                if (dataInput.value.trim() === '') {
                    statusArea.textContent = 'Waiting for input...';
                    statusArea.className = 'status-message status-info';
                    fitBtn.disabled = true;
                    return false;
                }
                if (data.length < 2) {
                    statusArea.textContent = 'Need at least 2 data points.';
                    statusArea.className = 'status-message status-error';
                    fitBtn.disabled = true;
                    return false;
                }
                if (invalidCount > 0) {
                    statusArea.textContent = `Warning: ${invalidCount} invalid values ignored.`;
                    statusArea.className = 'status-message status-error';
                } else {
                    statusArea.textContent = `${data.length} valid points ready.`;
                    statusArea.className = 'status-message status-info';
                }

                // Check distributions
                const checked = document.querySelectorAll('.dist-opt:checked').length;
                if (checked === 0) {
                    statusArea.textContent = 'Select at least one distribution.';
                    statusArea.className = 'status-message status-error';
                    fitBtn.disabled = true;
                    return false;
                }

                fitBtn.disabled = false;
                return true;
            };

            dataInput.addEventListener('input', validateInput);

            // --- Selection Handlers ---
            const getCheckboxes = () => document.querySelectorAll('.dist-opt');

            document.getElementById('select-all').onclick = (e) => {
                e.preventDefault();
                getCheckboxes().forEach(cb => cb.checked = true);
            };
            document.getElementById('select-continuous').onclick = (e) => {
                e.preventDefault();
                getCheckboxes().forEach(cb => cb.checked = cb.classList.contains('continuous'));
            };
            document.getElementById('select-discrete').onclick = (e) => {
                e.preventDefault();
                getCheckboxes().forEach(cb => cb.checked = cb.classList.contains('discrete'));
            };

            let currentFits = [];
            let currentData = [];
            let currentSelectedFit = null;
            let currentView = 'hist'; // 'hist' or 'qq'

            // --- FITTING LOGIC ---

            // Standard Normal PDF & Inv
            const pdfNormal = (x, mean, std) => jStat.normal.pdf(x, mean, std);
            const invNormal = (p, mean, std) => jStat.normal.inv(p, mean, std);

            // Exponential PDF & Inv
            const pdfExp = (x, rate) => x >= 0 ? jStat.exponential.pdf(x, rate) : 0;
            const invExp = (p, rate) => jStat.exponential.inv(p, rate);

            // Uniform PDF & Inv
            const pdfUniform = (x, a, b) => jStat.uniform.pdf(x, a, b);
            const invUniform = (p, a, b) => jStat.uniform.inv(p, a, b);

            // Poisson PMF & Inv (discrete)
            const pmfPoisson = (k, lambda) => Number.isInteger(k) && k >= 0 ? jStat.poisson.pdf(k, lambda) : 0;
            // jStat doesn't have poisson.inv easily exposed sometimes, use cdf search or approx?
            // jStat.poisson.cdf(k, lambda) exists.
            const invPoisson = (p, lambda) => {
                let k = 0;
                while (jStat.poisson.cdf(k, lambda) < p) {
                    k++;
                    if (k > 1000) break; // Safety
                }
                return k;
            };

            // Weibull PDF & Inv
            const pdfWeibull = (x, scale, shape) => x >= 0 ? jStat.weibull.pdf(x, scale, shape) : 0;
            const invWeibull = (p, scale, shape) => jStat.weibull.inv(p, scale, shape);

            // Gumbel PDF & Inv
            // PDF: f(x) = (1/beta) * exp( -(z + exp(-z)) ) where z = (x - mu) / beta
            // CDF: F(x) = exp( -exp(-z) )
            // Inv: x = mu - beta * ln( -ln(p) )
            const pdfGumbel = (x, mu, beta) => {
                const z = (x - mu) / beta;
                return (1 / beta) * Math.exp(-(z + Math.exp(-z)));
            };
            const invGumbel = (p, mu, beta) => {
                return mu - beta * Math.log(-Math.log(p));
            };


            // Calc AIC: 2k - 2ln(L)
            const calcAIC = (logLikelihood, k) => 2 * k - 2 * logLikelihood;

            const fitDistributions = (data, specificTypes = null) => {
                const n = data.length;
                const sum = jStat.sum(data);
                const mean = jStat.mean(data);
                const min = jStat.min(data);
                const max = jStat.max(data);
                const std = jStat.stdev(data, true); // sample std

                const results = [];
                const skipped = [];
                const selected = specificTypes || Array.from(document.querySelectorAll('.dist-opt:checked')).map(cb => cb.value);

                // 1. Normal
                if (selected.includes('normal')) {
                    const mu = mean;
                    const sigma = jStat.stdev(data, false);
                    let ll = 0;
                    for (let x of data) ll += Math.log(pdfNormal(x, mu, sigma) + 1e-10);

                    results.push({
                        name: 'Normal',
                        type: 'continuous',
                        params: { mean: mu, std: sigma },
                        aic: calcAIC(ll, 2),
                        pdf: (x) => pdfNormal(x, mu, sigma),
                        inv: (p) => invNormal(p, mu, sigma),
                        valueAt: (x, p) => pdfNormal(x, p.mean, p.std),
                        formattedParams: `μ=${mu.toFixed(4)}, σ=${sigma.toFixed(4)}`
                    });
                }

                // 2. Exponential (x >= 0)
                if (selected.includes('exponential')) {
                    if (min >= 0) {
                        const lambda = 1 / mean;
                        let ll = 0;
                        for (let x of data) ll += Math.log(pdfExp(x, lambda) + 1e-10);

                        results.push({
                            name: 'Exponential',
                            type: 'continuous',
                            params: { rate: lambda },
                            aic: calcAIC(ll, 1),
                            pdf: (x) => pdfExp(x, lambda),
                            inv: (p) => invExp(p, lambda),
                            valueAt: (x, p) => pdfExp(x, p.rate),
                            formattedParams: `λ=${lambda.toFixed(4)}`
                        });
                    } else {
                        skipped.push('Exponential (requires non-negative data)');
                    }
                }

                // 3. Uniform
                if (selected.includes('uniform')) {
                    const a = min;
                    const b = max;
                    let ll = 0;
                    for (let x of data) ll += Math.log(pdfUniform(x, a, b) + 1e-10);

                    results.push({
                        name: 'Uniform',
                        type: 'continuous',
                        params: { min: a, max: b },
                        aic: calcAIC(ll, 2),
                        pdf: (x) => pdfUniform(x, a, b),
                        inv: (p) => invUniform(p, a, b),
                        valueAt: (x, p) => pdfUniform(x, p.min, p.max),
                        formattedParams: `a=${a.toFixed(4)}, b=${b.toFixed(4)}`
                    });
                }

                // 4. Poisson (Integers >= 0)
                if (selected.includes('poisson')) {
                    const isInteger = data.every(x => Number.isInteger(x) && x >= 0);
                    if (isInteger) {
                        const lambda = mean; // MLE
                        let ll = 0;
                        for (let x of data) ll += Math.log(pmfPoisson(x, lambda) + 1e-10);

                        results.push({
                            name: 'Poisson',
                            type: 'discrete',
                            params: { lambda: lambda },
                            aic: calcAIC(ll, 1),
                            // For plotting discrete, we'll assume integer steps
                            pdf: (x) => pmfPoisson(Math.round(x), lambda),
                            inv: (p) => invPoisson(p, lambda),
                            valueAt: (x, p) => pmfPoisson(Math.round(x), p.lambda),
                            formattedParams: `λ=${lambda.toFixed(4)}`
                        });
                    } else {
                        skipped.push('Poisson (requires non-negative integers)');
                    }
                }

                // 5. Weibull (x >= 0)
                if (selected.includes('weibull')) {
                    if (min >= 0) {
                        const sorted = [...data].sort((a, b) => a - b);
                        const validData = sorted.filter(x => x > 0);

                        if (validData.length > 2) {
                            const xs = [];
                            const ys = [];
                            const n_v = validData.length;
                            for (let i = 0; i < n_v; i++) {
                                const p = (i + 0.5) / n_v;
                                ys.push(Math.log(-Math.log(1 - p)));
                                xs.push(Math.log(validData[i]));
                            }

                            const meanX = jStat.mean(xs);
                            const meanY = jStat.mean(ys);
                            let num = 0, den = 0;
                            for (let i = 0; i < xs.length; i++) {
                                num += (xs[i] - meanX) * (ys[i] - meanY);
                                den += (xs[i] - meanX) ** 2;
                            }
                            const k = num / den;
                            const intercept = meanY - k * meanX;
                            const lambda = Math.exp(-intercept / k);

                            let ll = 0;
                            for (let x of validData) ll += Math.log(pdfWeibull(x, lambda, k) + 1e-10);

                            results.push({
                                name: 'Weibull',
                                type: 'continuous',
                                params: { scale: lambda, shape: k },
                                aic: calcAIC(ll, 2),
                                pdf: (x) => pdfWeibull(x, lambda, k),
                                inv: (p) => invWeibull(p, lambda, k),
                                valueAt: (x, p) => pdfWeibull(x, p.scale, p.shape),
                                formattedParams: `λ=${lambda.toFixed(4)}, k=${k.toFixed(4)}`
                            });
                        } else {
                            skipped.push('Weibull (too few positive data points)');
                        }
                    } else {
                        skipped.push('Weibull (requires non-negative data)');
                    }
                }

                // 6. Gumbel (Extreme Value Type I)
                if (selected.includes('gumbel')) {
                    const gamma = 0.57721;
                    const beta = std * Math.sqrt(6) / Math.PI;
                    const mu = mean - gamma * beta;

                    let ll = 0;
                    for (let x of data) ll += Math.log(pdfGumbel(x, mu, beta) + 1e-10);

                    results.push({
                        name: 'Gumbel',
                        type: 'continuous',
                        params: { loc: mu, scale: beta },
                        aic: calcAIC(ll, 2),
                        pdf: (x) => pdfGumbel(x, mu, beta),
                        inv: (p) => invGumbel(p, mu, beta),
                        valueAt: (x, p) => pdfGumbel(x, p.loc, p.scale),
                        formattedParams: `μ=${mu.toFixed(4)}, β=${beta.toFixed(4)}`
                    });
                }

                // 7. Lognormal (x > 0)
                if (selected.includes('lognormal')) {
                    if (min > 0) {
                        const logData = data.map(x => Math.log(x));
                        const mu = jStat.mean(logData);
                        const sigma = jStat.stdev(logData, true);

                        const pdf = (x, mu, sigma) => {
                            if (x <= 0) return 0;
                            return (1 / (x * sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow(Math.log(x) - mu, 2) / (2 * sigma * sigma));
                        };
                        const inv = (p, mu, sigma) => Math.exp(jStat.normal.inv(p, mu, sigma));

                        let ll = 0;
                        for (let x of data) ll += Math.log(pdf(x, mu, sigma) + 1e-10);

                        results.push({
                            name: 'Lognormal',
                            type: 'continuous',
                            params: { mu: mu, sigma: sigma },
                            aic: calcAIC(ll, 2),
                            pdf: (x) => pdf(x, mu, sigma),
                            inv: (p) => inv(p, mu, sigma),
                            valueAt: (x, p) => pdf(x, p.mu, p.sigma),
                            formattedParams: `μ=${mu.toFixed(4)}, σ=${sigma.toFixed(4)}`
                        });
                    } else {
                        skipped.push('Lognormal (requires strictly positive data)');
                    }
                }

                // 8. Gamma (x > 0)
                if (selected.includes('gamma')) {
                    if (min > 0) {
                        // MOM Initial guess
                        const k_mom = (mean * mean) / (std * std);
                        const theta_mom = (std * std) / mean; // scale

                        // Simple optimization for k (shape) using Newton-Raphson on log-likelihood derivative is complex
                        // We will use a simple line search around MOM estimate to improve k
                        const logLikelihoodGamma = (k, theta, d) => {
                            let sum = 0;
                            for (let x of d) {
                                if (x <= 0) return -Infinity;
                                // log pdf = (k-1)ln(x) - x/theta - k ln(theta) - ln(Gamma(k))
                                sum += (k - 1) * Math.log(x) - x / theta - k * Math.log(theta) - jStat.gammaln(k);
                            }
                            return sum;
                        };

                        // Optimize k. Theta is determined by mean/k for MLE? No, theta = mean/k is MLE for theta given k.
                        // So we maximize L(k, mean/k).
                        let bestK = k_mom;
                        let bestLL = -Infinity;
                        // Search range: 0.5*mom to 2.0*mom, fine steps? Or assume MOM is good enough. 
                        // Let's do a small local search to refine.
                        for (let step = -0.5; step <= 0.5; step += 0.05) {
                            const tryK = k_mom * (1 + step);
                            if (tryK <= 0) continue;
                            const tryTheta = mean / tryK;
                            const currentLL = logLikelihoodGamma(tryK, tryTheta, data);
                            if (currentLL > bestLL) {
                                bestLL = currentLL;
                                bestK = tryK;
                            }
                        }

                        const k = bestK;
                        const theta = mean / k;

                        const pdf = (x, k, theta) => jStat.gamma.pdf(x, k, theta); // jStat uses shape, scale
                        const inv = (p, k, theta) => jStat.gamma.inv(p, k, theta);

                        results.push({
                            name: 'Gamma',
                            type: 'continuous',
                            params: { shape: k, scale: theta },
                            aic: calcAIC(bestLL, 2),
                            pdf: (x) => pdf(x, k, theta),
                            inv: (p) => inv(p, k, theta),
                            valueAt: (x, p) => pdf(x, p.shape, p.scale),
                            formattedParams: `k=${k.toFixed(4)}, θ=${theta.toFixed(4)}`
                        });
                    } else {
                        skipped.push('Gamma (requires strictly positive data)');
                    }
                }

                // 9. Pareto (Type I) (x >= xm)
                if (selected.includes('pareto')) {
                    // MLE: xm = min(data), alpha = n / sum(ln(xi/xm))
                    const xm = min;
                    let sumLn = 0;
                    for (let x of data) sumLn += Math.log(x / xm);
                    const alpha = n / sumLn;

                    const pdf = (x, xm, alpha) => (x >= xm) ? (alpha * Math.pow(xm, alpha)) / Math.pow(x, alpha + 1) : 0;
                    const inv = (p, xm, alpha) => xm / Math.pow(1 - p, 1 / alpha);

                    let ll = 0;
                    for (let x of data) ll += Math.log(pdf(x, xm, alpha) + 1e-10);

                    results.push({
                        name: 'Pareto',
                        type: 'continuous',
                        params: { xm: xm, alpha: alpha },
                        aic: calcAIC(ll, 2),
                        pdf: (x) => pdf(x, xm, alpha),
                        inv: (p) => inv(p, xm, alpha),
                        valueAt: (x, p) => pdf(x, p.xm, p.alpha),
                        formattedParams: `xm=${xm.toFixed(4)}, α=${alpha.toFixed(4)}`
                    });
                }

                // 10. GEV (Generalized Extreme Value)
                if (selected.includes('gev')) {
                    // Parameters: mu (loc), sigma (scale), xi (shape)
                    // If xi=0, Gumbel.
                    // Numerical MLE required. 3 parameters.
                    // Initial guess: L-moments or MOM roughly? 
                    // Let's assume Gumbel fit as starting point (xi=0).
                    const gumbelBeta = std * Math.sqrt(6) / Math.PI;
                    const gumbelMu = mean - 0.57721 * gumbelBeta;

                    const logLikelihoodGEV = (mu, sigma, xi, d) => {
                        if (sigma <= 0) return -Infinity;
                        let sum = 0;
                        for (let x of d) {
                            const s = (x - mu) / sigma;
                            const t = (xi === 0) ? Math.exp(-s) : Math.pow(1 + xi * s, -1 / xi);
                            if (xi !== 0 && (1 + xi * s) <= 0) return -Infinity; // Support constraint
                            const logPdf = -Math.log(sigma) + (xi + 1) * Math.log(t) - t; // Check this def?
                            // Standard form: f(x) = (1/sigma) * t^(xi+1) * e^(-t)
                            // But usually defined t(x) = ...
                            // Correct Log PDF: -log(sigma) - (1 + 1/xi)*log(1 + xi*s) - (1 + xi*s)^(-1/xi)
                            // Wait, let's use the explicit form:
                            // z = (x - mu)/sigma
                            // if xi != 0: t = (1 + xi*z)^(-1/xi). log_pdf = -log(sigma) + (xi+1)*log(t) - t? No.
                            // Typically: L = -n log sigma - (1 + 1/xi) sum log(1+xi zi) - sum (1+xi zi)^(-1/xi)

                            let term1, term2;
                            if (Math.abs(xi) < 1e-5) {
                                // Gumbel limit
                                const e_z = Math.exp(-s);
                                sum += -Math.log(sigma) - s - e_z;
                            } else {
                                if (1 + xi * s <= 0) return -Infinity;
                                term1 = Math.log(1 + xi * s);
                                term2 = Math.pow(1 + xi * s, -1 / xi);
                                sum += -Math.log(sigma) - (1 + 1 / xi) * term1 - term2;
                            }
                        }
                        return sum;
                    };

                    // Simple Nelder-Mead or Grid Search?
                    // We'll search xi in small range [-0.5, 0.5] and refine mu, sigma.
                    // Heuristic: Fix xi, opt mu/sigma? or Search all 3.
                    // Simplification: Search xi in discrete steps, optimize mu/sigma conditional?
                    // Even simpler: Check if xi ~ 0 (Gumbel), positive (Frechet), negative (Weibull-like).
                    // We'll perform a randomized local search around the Gumbel parameters.

                    let bestParams = { mu: gumbelMu, sigma: gumbelBeta, xi: 0 };
                    let maxLL = logLikelihoodGEV(gumbelMu, gumbelBeta, 0, data);

                    const attempts = 50;
                    for (let i = 0; i < attempts; i++) {
                        // Perturb
                        const t_xi = (Math.random() - 0.5); // -0.5 to 0.5
                        const t_mu = gumbelMu + (Math.random() - 0.5) * gumbelBeta;
                        const t_sigma = gumbelBeta * (0.5 + Math.random()); // 0.5 to 1.5x

                        const ll = logLikelihoodGEV(t_mu, t_sigma, t_xi, data);
                        if (ll > maxLL) {
                            maxLL = ll;
                            bestParams = { mu: t_mu, sigma: t_sigma, xi: t_xi };
                        }
                    }

                    // PDF & Inv
                    const pdf = (x, mu, sigma, xi) => {
                        const s = (x - mu) / sigma;
                        if (Math.abs(xi) < 1e-5) {
                            const z = Math.exp(-s);
                            return (1 / sigma) * z * Math.exp(-z);
                        }
                        if (1 + xi * s <= 0) return 0;
                        const t = Math.pow(1 + xi * s, -1 / xi);
                        return (1 / sigma) * Math.pow(t, xi + 1) * Math.exp(-t);
                    };

                    const inv = (p, mu, sigma, xi) => {
                        if (Math.abs(xi) < 1e-5) {
                            return mu - sigma * Math.log(-Math.log(p));
                        }
                        return mu + (sigma / xi) * (Math.pow(-Math.log(p), -xi) - 1);
                    };

                    results.push({
                        name: 'GEV',
                        type: 'continuous',
                        params: bestParams,
                        aic: calcAIC(maxLL, 3),
                        pdf: (x) => pdf(x, bestParams.mu, bestParams.sigma, bestParams.xi),
                        inv: (p) => inv(p, bestParams.mu, bestParams.sigma, bestParams.xi),
                        valueAt: (x, p) => pdf(x, p.mu, p.sigma, p.xi),
                        formattedParams: `μ=${bestParams.mu.toFixed(2)}, σ=${bestParams.sigma.toFixed(2)}, ξ=${bestParams.xi.toFixed(3)}`
                    });
                }

                // 11. Negative Binomial (Discrete) (Overdispersed counts: Var > Mean)
                if (selected.includes('negbin')) {
                    const isInteger = data.every(x => Number.isInteger(x) && x >= 0);
                    if (isInteger) {
                        const vari = jStat.variance(data, true);
                        const m = mean;

                        if (vari > m) {
                            // MOM Estimation
                            // p = m / var, r = m*p / (1-p) ? No.
                            // var = r(1-p)/p^2, mean = r(1-p)/p (Type I) or r(1-p)/p
                            // Wikipedia: p = probability of success. Mean = pr/(1-p). Var = pr/(1-p)^2.
                            // Alternative param: r (failures), p. Mean = r(1-p)/p.
                            // Convention: Mean = m, Variance = v.
                            // p_est = m / v. r_est = m^2 / (v - m).

                            let p = m / vari;
                            let r = (m * m) / (vari - m);

                            // PMF: Gamma(k+r)/(k! Gamma(r)) * p^r * (1-p)^k
                            // k is number of failures (x).
                            // Let's implement LogLikelihood to refine or just use MOM.
                            // MOM is usually fine for initial check.

                            const combination = (k, r) => {
                                // Use log gamma for stability
                                // ln(C) = lnGamma(k+r) - lnGamma(k+1) - lnGamma(r)
                                return Math.exp(jStat.gammaln(k + r) - jStat.gammaln(k + 1) - jStat.gammaln(r));
                            };
                            const pmf = (k, r, p) => {
                                if (k < 0 || !Number.isInteger(k)) return 0;
                                return combination(k, r) * Math.pow(p, r) * Math.pow(1 - p, k);
                            };

                            // Helper for Inv.
                            const inv = (q, r, p) => {
                                let sum = 0;
                                let k = 0;
                                while (sum < q) {
                                    sum += pmf(k, r, p);
                                    if (sum >= q) return k;
                                    k++;
                                    if (k > 2000) break;
                                }
                                return k;
                            };

                            let ll = 0;
                            for (let x of data) ll += Math.log(pmf(x, r, p) + 1e-10);

                            results.push({
                                name: 'Negative Binomial',
                                type: 'discrete',
                                params: { r: r, p: p },
                                aic: calcAIC(ll, 2),
                                pdf: (x) => pmf(Math.round(x), r, p),
                                inv: (q) => inv(q, r, p),
                                valueAt: (x, p) => pmf(Math.round(x), p.r, p.p),
                                formattedParams: `r=${r.toFixed(2)}, p=${p.toFixed(3)}`
                            });

                        } else {
                            skipped.push('Negative Binomial (requires Variance > Mean)');
                        }
                    } else {
                        skipped.push('Negative Binomial (requires non-negative integers)');
                    }
                }

                // 12. Binomial (Discrete) (Bounded integers)
                if (selected.includes('binomial')) {
                    const isInteger = data.every(x => Number.isInteger(x) && x >= 0);
                    if (isInteger) {
                        const m = mean;
                        const v = jStat.variance(data, true);

                        // MME: mean = np, var = np(1-p).
                        // p = 1 - v/m. n = m/p.
                        // Valid only if v < m (underdispersion).
                        if (v < m) {
                            let p = 1 - (v / m);
                            let n_est = Math.round(m / p); // n must be integer
                            // Recalculate p based on integer n? p = m/n
                            p = m / n_est;

                            // Check if max(data) <= n
                            const maxVal = Math.max(...data);
                            if (maxVal > n_est) n_est = maxVal; // Force n to conform data

                            const pmf = (k, n, p) => {
                                if (k < 0 || k > n || !Number.isInteger(k)) return 0;
                                return jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
                            };

                            const inv = (q, n, p) => {
                                let sum = 0;
                                for (let k = 0; k <= n; k++) {
                                    sum += pmf(k, n, p);
                                    if (sum >= q) return k;
                                }
                                return n;
                            };

                            let ll = 0;
                            for (let x of data) ll += Math.log(pmf(x, n_est, p) + 1e-10);

                            results.push({
                                name: 'Binomial',
                                type: 'discrete',
                                params: { n: n_est, p: p },
                                aic: calcAIC(ll, 2),
                                pdf: (x) => pmf(Math.round(x), n_est, p),
                                inv: (q) => inv(q, n_est, p),
                                valueAt: (x, p) => pmf(Math.round(x), p.n, p.p),
                                formattedParams: `n=${n_est}, p=${p.toFixed(3)}`
                            });
                        } else {
                            skipped.push('Binomial (Variance >= Mean, implies Poisson/NegBin)');
                        }
                    } else {
                        skipped.push('Binomial (requires non-negative integers)');
                    }
                }

                // --- Add CDFs and Calculate Metrics ---

                // Add CDFs for PP plots
                results.forEach(res => {
                    if (!res.cdf) {
                        if (res.name === 'Normal') res.cdf = (x) => jStat.normal.cdf(x, res.params.mean, res.params.std);
                        if (res.name === 'Exponential') res.cdf = (x) => jStat.exponential.cdf(x, res.params.rate);
                        if (res.name === 'Uniform') res.cdf = (x) => jStat.uniform.cdf(x, res.params.min, res.params.max);
                        if (res.name === 'Weibull') res.cdf = (x) => jStat.weibull.cdf(x, res.params.scale, res.params.shape);
                        if (res.name === 'Lognormal') res.cdf = (x) => jStat.lognormal.cdf(x, res.params.mu, res.params.sigma);
                        if (res.name === 'Gamma') res.cdf = (x) => jStat.gamma.cdf(x, res.params.shape, res.params.scale);
                        if (res.name === 'Poisson') res.cdf = (x) => jStat.poisson.cdf(Math.floor(x), res.params.lambda);

                        if (res.name === 'Gumbel') {
                            res.cdf = (x) => {
                                const z = (x - res.params.loc) / res.params.scale;
                                return Math.exp(-Math.exp(-z));
                            };
                        }
                        if (res.name === 'Pareto') {
                            res.cdf = (x) => {
                                if (x < res.params.xm) return 0;
                                return 1 - Math.pow(res.params.xm / x, res.params.alpha);
                            };
                        }
                        if (res.name === 'GEV') {
                            res.cdf = (x) => {
                                const mu = res.params.mu;
                                const sigma = res.params.sigma;
                                const xi = res.params.xi;
                                const s = (x - mu) / sigma;
                                if (Math.abs(xi) < 1e-5) return Math.exp(-Math.exp(-s));
                                if (1 + xi * s <= 0) return xi > 0 ? 0 : 1;
                                return Math.exp(-Math.pow(1 + xi * s, -1 / xi));
                            };
                        }
                        if (res.name === 'Negative Binomial') {
                            res.cdf = (x) => {
                                const k_end = Math.floor(x);
                                if (k_end < 0) return 0;
                                let sum = 0;
                                for (let k = 0; k <= k_end; k++) {
                                    sum += res.pdf(k);
                                }
                                return Math.min(1, sum);
                            };
                        }
                        if (res.name === 'Binomial') {
                            res.cdf = (x) => {
                                const k_end = Math.floor(x);
                                if (k_end < 0) return 0;
                                let sum = 0;
                                for (let k = 0; k <= k_end; k++) {
                                    sum += res.pdf(k);
                                }
                                return Math.min(1, sum);
                            };
                        }
                    }
                });

                results.sort((a, b) => a.aic - b.aic);

                if (results.length > 0) {
                    const minAIC = results[0].aic;
                    let sumExp = 0;
                    results.forEach(r => {
                        r.deltaAIC = r.aic - minAIC;
                        r.weightRaw = Math.exp(-0.5 * r.deltaAIC);
                        sumExp += r.weightRaw;
                    });
                    results.forEach(r => {
                        r.weight = r.weightRaw / sumExp;
                    });
                }

                return { results, skipped };
            };

            // --- Plotting ---
            // --- Plotting ---

            const renderVisualization = (data, fit) => {
                if (chartInstance) {
                    chartInstance.destroy();
                }

                if (currentView === 'qq') {
                    updateQQPlot(data, fit);
                } else if (currentView === 'stab') {
                    updateStabilityPlot(data, fit);
                } else {
                    updateHistogram(data, fit);
                }
                updateDiagnostics(fit);
            };

            const updateDiagnostics = (fit) => {
                const diagText = document.getElementById('diagnostics-text');
                if (!fit) {
                    diagText.textContent = "Select a distribution to see diagnostics.";
                    return;
                }

                let text = "";
                if (currentView === 'hist') {
                    text = `<strong>Histogram Check:</strong> Look for how well the red curve overlays the blue bars. Good fits follow the shape closely. Gaps or spikes suggest the model may not capture all data features.`;
                } else if (currentView === 'qq') {
                    text = `<strong>Q-Q Plot Assessment:</strong> Points should fall along the dashed diagonal line. <br>
                    - <em>Curves at ends:</em> The distribution tail weight differs from data.<br>
                    - <em>S-shape:</em> Skewness mismatch.<br>
                    Points far from the line indicate a poor fit.`;
                } else if (currentView === 'stab') {
                    text = `<strong>Rate Stability Check:</strong> Used to check if the mean rate is constant (stationary). <br>
                    - Data (blue line) should roughly follow the straight reference (dashed).<br>
                    - <em>Bending up/down:</em> Implementation suggests the rate (mean) changes over time (non-stationary).<br>
                    This is most relevant for Poisson/Exponential processes.<br>
                    <em>Note: Assumes ordered observations represent time.</em>`;
                }

                if (fit.ciFailed) {
                    text += `<br><br><strong style="color: #d32f2f">Warning:</strong> Confidence intervals could not be reliably estimated for this model.`;
                }

                diagText.innerHTML = text;
            };

            const updateStabilityPlot = (data, fit) => {
                // Plot Cumulative Sum vs Index
                // Ref line slope = mean
                const n = data.length;
                const cumSum = [];
                let runningSum = 0;
                for (let x of data) {
                    runningSum += x;
                    cumSum.push(runningSum);
                }

                // Reference line: Slope = Fit Mean (or sample mean if fit matches)
                // We use fit params to be rigorous about "checking the fit"
                // For most distributions, E[X] is available. 
                let estimatedMean = jStat.mean(data);
                if (fit) {
                    if (fit.name === 'Exponential') estimatedMean = 1 / fit.params.rate;
                    if (fit.name === 'Poisson') estimatedMean = fit.params.lambda;
                    if (fit.name === 'Normal') estimatedMean = fit.params.mean;
                    if (fit.name === 'Uniform') estimatedMean = (fit.params.min + fit.params.max) / 2;
                    // For others, we might rely on sample mean or derivation
                }

                const refData = [
                    { x: 0, y: 0 },
                    { x: n, y: estimatedMean * n }
                ];

                // Data points: (i+1, cumSum[i])
                const plotData = cumSum.map((val, idx) => ({ x: idx + 1, y: val }));

                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: 'Observed Cumulative',
                                data: plotData,
                                borderColor: 'rgba(15, 111, 255, 1)',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: 0,
                                tension: 0.1,
                                order: 1
                            },
                            {
                                label: `Expected (Mean = ${estimatedMean.toFixed(2)})`,
                                data: refData,
                                borderColor: '#ff6b6b',
                                borderDash: [5, 5],
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Rate Stability / Stationarity Check'
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'Observation Index' },
                                min: 0
                            },
                            y: {
                                type: 'linear',
                                title: { display: true, text: 'Cumulative Value' }
                            }
                        }
                    }
                });

            };

            const updateQQPlot = (data, bestFit) => {
                if (!bestFit) return;

                const isDiscrete = (bestFit.type === 'discrete');
                const useUpperTail = document.getElementById('upper-tail-only').checked;

                const n = data.length;
                const sorted = [...data].sort((a, b) => a - b);
                let scatterData = [];

                let xLabel = 'Theoretical Quantiles';
                let yLabel = 'Empirical Quantiles';
                let title = `${bestFit.name} Q-Q Plot`;

                if (isDiscrete) {
                    title = `${bestFit.name} P-P Plot`;
                    xLabel = 'Model Probability (CDF)';
                    yLabel = 'Empirical Probability';

                    for (let i = 0; i < n; i++) {
                        const p_emp = (i + 0.5) / n;
                        const p_model = bestFit.cdf(sorted[i]);
                        scatterData.push({ x: p_model, y: p_emp });
                    }
                } else {
                    for (let i = 0; i < n; i++) {
                        const p = (i + 0.5) / n;
                        const theoreticalQ = bestFit.inv(p);
                        scatterData.push({ x: theoreticalQ, y: sorted[i] });
                    }
                }

                // Filter for upper tail if requested
                if (useUpperTail) {
                    // Top 10%
                    const startIndex = Math.floor(n * 0.9);
                    scatterData = scatterData.slice(startIndex);
                }

                // Reference line
                let refData = [];
                if (isDiscrete) {
                    refData = [{ x: 0, y: 0 }, { x: 1, y: 1 }];
                    if (useUpperTail && scatterData.length > 0) {
                        const minVal = Math.min(scatterData[0].x, scatterData[0].y);
                        refData = [{ x: minVal, y: minVal }, { x: 1, y: 1 }];
                    }
                } else {
                    if (scatterData.length > 0) {
                        const allVals = scatterData.flatMap(p => [p.x, p.y]);
                        const min = jStat.min(allVals);
                        const max = jStat.max(allVals);
                        refData = [{ x: min, y: min }, { x: max, y: max }];
                    }
                }

                chartInstance = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: isDiscrete ? 'Probabilities' : 'Quantiles',
                                data: scatterData,
                                backgroundColor: 'rgba(15, 111, 255, 0.6)',
                                borderColor: 'rgba(15, 111, 255, 1)',
                                order: 1
                            },
                            {
                                label: 'Reference Line',
                                data: refData,
                                type: 'line',
                                borderColor: '#ccc',
                                borderDash: [5, 5],
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                animation: false,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: xLabel }
                            },
                            y: {
                                type: 'linear',
                                title: { display: true, text: yLabel }
                            }
                        }
                    }
                });
            };

            const updateHistogram = (data, bestFit) => {
                const binInputVal = parseInt(document.getElementById('bin-count').value);
                const binCount = (binInputVal && binInputVal > 1) ? binInputVal : Math.max(5, Math.floor(Math.sqrt(data.length)));
                const min = jStat.min(data);
                const max = jStat.max(data);
                const range = max - min;
                const step = range / binCount;

                // Create bins
                const bins = new Array(binCount).fill(0);

                for (let x of data) {
                    let idx = Math.floor((x - min) / step);
                    if (idx >= binCount) idx = binCount - 1;
                    bins[idx]++;
                }

                // Normalized density for histogram with numeric x-coordinates
                const histogramData = [];
                for (let i = 0; i < binCount; i++) {
                    const center = min + (i + 0.5) * step;
                    const densityVal = bins[i] / (data.length * step);
                    histogramData.push({ x: center, y: densityVal });
                }

                // Best Fit Curve points
                const curveData = [];
                if (bestFit) {
                    const curvePoints = 100;
                    const curveStep = range / curvePoints;
                    for (let i = 0; i <= curvePoints; i++) {
                        const x = min + i * curveStep;
                        curveData.push({ x: x, y: bestFit.pdf(x) });
                    }
                }

                // CI Bands
                const ciUpperData = [];
                const ciLowerData = [];

                if (bestFit && bestFit.bootstrapParams && bestFit.bootstrapParams.length >= 50 && bestFit.valueAt) {
                    const curvePoints = 100;
                    const curveStep = range / curvePoints;

                    for (let i = 0; i <= curvePoints; i++) {
                        const x = min + i * curveStep;
                        // For discrete, maybe align x to integers? But this is for drawing bands.
                        // pdf functions handle x locally.
                        const values = bestFit.bootstrapParams.map(p => bestFit.valueAt(x, p));
                        values.sort((a, b) => a - b);
                        const lower = values[Math.floor(0.025 * values.length)];
                        const upper = values[Math.ceil(0.975 * values.length) - 1];
                        ciLowerData.push({ x: x, y: lower });
                        ciUpperData.push({ x: x, y: upper });
                    }
                }

                chartInstance = new Chart(ctx, {
                    type: 'bar', // Base type
                    data: {
                        datasets: [
                            {
                                label: 'Data Density',
                                data: histogramData,
                                backgroundColor: 'rgba(15, 111, 255, 0.4)',
                                borderColor: 'rgba(15, 111, 255, 1)',
                                borderWidth: 1,
                                barPercentage: 1.0,
                                categoryPercentage: 1.0,
                                order: 3
                            },
                            // CI Band (Upper) - Fills to next dataset (Lower)
                            (ciUpperData.length > 0) ? {
                                label: '95% CI',
                                data: ciUpperData,
                                type: 'line',
                                borderColor: 'transparent', // Invisible border
                                backgroundColor: 'rgba(255, 107, 107, 0.2)', // Shaded area
                                fill: { target: '+1' }, // Fill to next dataset
                                pointRadius: 0,
                                tension: 0.4,
                                order: 2
                            } : null,
                            // CI Band (Lower)
                            (ciLowerData.length > 0) ? {
                                label: 'CI Lower', // Hidden from legend usually?
                                data: ciLowerData,
                                type: 'line',
                                borderColor: 'transparent',
                                fill: false,
                                pointRadius: 0,
                                tension: 0.4,
                                order: 2,
                                hidden: false // Keep visible for fill target
                            } : null,
                            bestFit ? {
                                label: `${bestFit.name} Fit`,
                                data: curveData, // Scatter points treated as line
                                type: 'line',
                                borderColor: '#ff6b6b',
                                borderWidth: 3,
                                pointRadius: 0,
                                fill: false,
                                tension: 0.4,
                                order: 1
                            } : null
                        ].filter(x => x)
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'linear',
                                min: min,
                                max: max,
                                title: { display: true, text: 'Value' },
                                offset: false,
                            },
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'Density' }
                            }
                        },
                        plugins: {
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                filter: function (tooltipItem) {
                                    // Hide CI Lower tooltip
                                    return tooltipItem.dataset.label !== 'CI Lower';
                                }
                            },
                            legend: {
                                labels: {
                                    filter: function (item, chart) {
                                        // Hide CI Lower
                                        return !item.text.includes('CI Lower');
                                    }
                                }
                            }
                        }
                    }
                });
            };

            const selectFit = (fit, row) => {
                currentSelectedFit = fit;
                // Update chart
                renderVisualization(currentData, fit);

                // Update params display
                // Update params display
                if (fit) {
                    let output = `Selected Fit: ${fit.name}\n`;

                    // Format params with CI if available
                    Object.keys(fit.params).forEach(key => {
                        const val = fit.params[key];
                        let line = `${key} = ${val.toFixed(4)}`;

                        if (fit.confidenceIntervals && fit.confidenceIntervals[key]) {
                            const ci = fit.confidenceIntervals[key];
                            line += `  [${ci.lower.toFixed(4)}, ${ci.upper.toFixed(4)}]`;
                        }
                        output += line + '\n';
                    });

                    if (fit.ciFailed) {
                        output += '\nWarning: Confidence intervals could not be reliably estimated for this model.\n';
                    }

                    paramsOutput.textContent = output;
                }

                // Update UI highlighting
                document.querySelectorAll('.results-table tr').forEach(r => r.classList.remove('selected-row'));
                if (row) {
                    row.classList.add('selected-row');
                }
            };

            // --- BOOTSTRAP LOGIC ---

            const resampleData = (data) => {
                const n = data.length;
                const sample = new Array(n);
                for (let i = 0; i < n; i++) {
                    sample[i] = data[Math.floor(Math.random() * n)];
                }
                return sample;
            };

            const runBootstrap = async (originalData, fitResult) => {
                const B = 300;
                const validParams = [];

                const typeMap = {
                    'Normal': 'normal',
                    'Exponential': 'exponential',
                    'Uniform': 'uniform',
                    'Weibull': 'weibull',
                    'Gumbel': 'gumbel',
                    'Lognormal': 'lognormal',
                    'Gamma': 'gamma',
                    'GEV': 'gev',
                    'Pareto': 'pareto',
                    'Poisson': 'poisson',
                    'Negative Binomial': 'negbin',
                    'Binomial': 'binomial'
                };
                const typeKey = typeMap[fitResult.name];
                if (!typeKey) return null;

                const chunkSize = 20; // Process 20 iterations before yielding

                for (let i = 0; i < B; i += chunkSize) {
                    // Yield to event loop to keep UI responsive
                    await new Promise(r => setTimeout(r, 0));

                    const limit = Math.min(i + chunkSize, B);
                    for (let j = i; j < limit; j++) {
                        const sample = resampleData(originalData);
                        // Silence errors/warnings during bootstrap
                        try {
                            // fitDistributions returns { results, skipped }
                            // We only care if we get a result for our specific type
                            const { results } = fitDistributions(sample, [typeKey]);
                            if (results.length > 0) {
                                validParams.push(results[0].params);
                            }
                        } catch (e) {
                            // Ignore fit failures during bootstrap
                        }
                    }
                }

                if (validParams.length < 50) {
                    return { valid: false };
                }

                // Compute quantiles
                const ci = {};
                const paramNames = Object.keys(validParams[0]);
                paramNames.forEach(pName => {
                    const values = validParams.map(p => p[pName]).sort((a, b) => a - b);
                    const lowerIndex = Math.floor(0.025 * values.length);
                    const upperIndex = Math.ceil(0.975 * values.length) - 1;
                    ci[pName] = {
                        lower: values[Math.max(0, lowerIndex)],
                        upper: values[Math.min(values.length - 1, upperIndex)]
                    };
                });

                return { valid: true, ci, bootstrapParams: validParams };
            };

            fitBtn.addEventListener('click', async () => {
                if (!validateInput()) return;

                const { data } = parseData(dataInput.value);
                currentData = data;

                const { results: fits, skipped } = fitDistributions(data);
                currentFits = fits;

                // Show Table
                resultsArea.style.display = 'block';
                resultsBody.innerHTML = '';
                const warningBox = document.getElementById('warnings-area');
                warningBox.style.display = 'none';

                if (fits.length === 0) {
                    resultsBody.innerHTML = '<tr><td colspan="5">No valid distributions found.</td></tr>';
                    currentSelectedFit = null;
                    paramsOutput.textContent = '';
                    updateHistogram(data, null);
                } else {
                    fits.forEach((fit, idx) => {
                        const row = document.createElement('tr');
                        // Add best fit styling to first
                        if (idx === 0) row.classList.add('rank-1');

                        row.innerHTML = `
                            <td>${idx + 1}</td>
                            <td><strong>${fit.name}</strong><br><small>${fit.formattedParams}</small></td>
                            <td>${fit.aic.toFixed(2)}</td>
                            <td>${fit.deltaAIC.toFixed(2)}</td>
                            <td>${fit.weight.toFixed(3)}</td>
                        `;

                        // Add interactive click
                        row.onclick = () => selectFit(fit, row);

                        resultsBody.appendChild(row);

                        // Select best fit by default
                        if (idx === 0) {
                            selectFit(fit, row);
                            // Ensure we reset to histogram view on new fit
                            setView('hist');
                        }
                    });
                }

                // Show skipped messages
                if (skipped.length > 0) {
                    warningBox.style.display = 'block';
                    warningBox.innerHTML = `<strong>Skipped Distributions:</strong><ul style="margin:5px 0 0 20px; padding:0;">${skipped.map(s => `<li>${s}</li>`).join('')}</ul>`;
                }

                checkDataInsights(data);

                // Start Bootstrap Process in background
                if (fits.length > 0) {
                    statusArea.textContent = 'Computing confidence intervals...';

                    // We run sequentially to avoid clogging the event loop completely, 
                    // though parallel promises with yielding might be faster but riskier for responsiveness.
                    for (let fit of fits) {
                        try {
                            const bsResult = await runBootstrap(data, fit);
                            if (bsResult && bsResult.valid) {
                                fit.confidenceIntervals = bsResult.ci;
                                fit.bootstrapParams = bsResult.bootstrapParams;
                            } else {
                                // Add warning locally to the fit object or global?
                                // User rule: "Add a short warning in the diagnostics panel"
                                fit.ciFailed = true;
                            }
                        } catch (e) {
                            console.error("Bootstrap error for " + fit.name, e);
                            fit.ciFailed = true;
                        }
                    }

                    statusArea.textContent = `Fit and CI computation complete.`;

                    // Refresh current selection if it exists
                    if (currentSelectedFit) {
                        // Re-select to update text output and plots
                        const currentRow = Array.from(document.querySelectorAll('.results-table tr')).find(r => r.classList.contains('selected-row'));
                        selectFit(currentSelectedFit, currentRow);
                    }
                }
            });

            // Re-render chart on bin change using SELECTED fit
            document.getElementById('bin-count').addEventListener('input', () => {
                // Do not refit, just update chart with current selected fit
                if (currentData.length < 2) return;
                renderVisualization(currentData, currentSelectedFit);
            });

            // View Toggles
            const btnHist = document.getElementById('view-hist');
            const btnQQ = document.getElementById('view-qq');
            const btnStab = document.getElementById('view-stab');
            const qqOptions = document.getElementById('qq-options');

            const setView = (view) => {
                currentView = view;
                qqOptions.style.display = (view === 'qq') ? 'flex' : 'none';

                // Update buttons
                if (view === 'hist') {
                    btnHist.classList.add('active');
                    btnHist.style.background = '#fff';
                    btnHist.style.color = '#0f6fff';
                    btnHist.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';

                    btnQQ.classList.remove('active');
                    btnQQ.style.background = 'transparent';
                    btnQQ.style.color = '#555';
                    btnQQ.style.boxShadow = 'none';

                    btnStab.classList.remove('active');
                    btnStab.style.background = 'transparent';
                    btnStab.style.color = '#555';
                    btnStab.style.boxShadow = 'none';

                    document.getElementById('bin-count').parentElement.style.visibility = 'visible';
                } else if (view === 'qq') {
                    btnQQ.classList.add('active');
                    btnQQ.style.background = '#fff';
                    btnQQ.style.color = '#0f6fff';
                    btnQQ.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';

                    btnHist.classList.remove('active');
                    btnHist.style.background = 'transparent';
                    btnHist.style.color = '#555';
                    btnHist.style.boxShadow = 'none';

                    btnStab.classList.remove('active');
                    btnStab.style.background = 'transparent';
                    btnStab.style.color = '#555';
                    btnStab.style.boxShadow = 'none';

                    document.getElementById('bin-count').parentElement.style.visibility = 'hidden';
                } else { // Stability
                    btnHist.classList.remove('active');
                    btnQQ.classList.remove('active');
                    btnStab.classList.add('active');

                    [btnHist, btnQQ].forEach(btn => {
                        btn.style.background = 'transparent';
                        btn.style.color = '#555';
                        btn.style.boxShadow = 'none';
                    });

                    btnStab.style.background = '#fff';
                    btnStab.style.color = '#0f6fff';
                    btnStab.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';
                    document.getElementById('bin-count').parentElement.style.visibility = 'hidden';
                }

                // Re-render
                if (currentData.length > 0) {
                    renderVisualization(currentData, currentSelectedFit);
                }
            };

            btnHist.addEventListener('click', () => setView('hist'));
            btnQQ.addEventListener('click', () => setView('qq'));
            btnStab.addEventListener('click', () => setView('stab'));

            // Export to PNG
            document.getElementById('export-btn').addEventListener('click', () => {
                const link = document.createElement('a');
                let filename = 'distribution_fit.png';
                if (currentView === 'qq') filename = 'qq_plot.png';
                else if (currentView === 'stab') filename = 'rate_stability.png';

                link.download = filename;
                link.href = document.getElementById('fit-chart').toDataURL('image/png');
                link.click();
            });

            // Export JSON
            document.getElementById('export-json').addEventListener('click', () => {
                if (currentFits.length === 0) return;
                const exportObj = {
                    summary: {
                        n: currentData.length,
                        mean: jStat.mean(currentData),
                        variance: jStat.variance(currentData, true),
                        min: jStat.min(currentData),
                        max: jStat.max(currentData)
                    },
                    fits: currentFits.map(f => ({
                        name: f.name,
                        params: f.params,
                        confidenceIntervals: f.confidenceIntervals,
                        aic: f.aic,
                        deltaAIC: f.deltaAIC,
                        weight: f.weight
                    }))
                };
                const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `distribution_fit_${Date.now()}.json`;
                link.click();
            });

            // Export CSV
            document.getElementById('export-csv').addEventListener('click', () => {
                if (currentFits.length === 0) return;

                // Header
                let csv = 'Rank,Distribution,AIC,DeltaAIC,Weight,Parameters,Confidence_Intervals\n';

                currentFits.forEach((f, idx) => {
                    const paramsStr = Object.entries(f.params)
                        .map(([k, v]) => `${k}=${v.toFixed(4)}`)
                        .join('; ');

                    let ciStr = '';
                    if (f.confidenceIntervals) {
                        ciStr = Object.entries(f.confidenceIntervals)
                            .map(([k, v]) => `${k}_lower=${v.lower.toFixed(4)}; ${k}_upper=${v.upper.toFixed(4)}`)
                            .join('; ');
                    }

                    // Sanitize for CSV (simple quote escape if needed, though mostly numeric)
                    csv += `${idx + 1},"${f.name}",${f.aic.toFixed(2)},${f.deltaAIC.toFixed(2)},${f.weight.toFixed(4)},"${paramsStr}","${ciStr}"\n`;
                });

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `distribution_fit_${Date.now()}.csv`;
                link.click();
            });



            // Toggle Upper Tail Only
            document.getElementById('upper-tail-only').addEventListener('change', () => {
                if (currentView === 'qq') {
                    renderVisualization(currentData, currentSelectedFit);
                }
            });

            // Checkboxes event to trigger validation
            document.querySelectorAll('.dist-opt').forEach(cb => {
                cb.addEventListener('change', validateInput);
            });

            const checkDataInsights = (data) => {
                const insightsPanel = document.getElementById('insights-panel');
                const insightsList = document.getElementById('insights-list');
                insightsList.innerHTML = '';
                let hints = [];

                if (!data || data.length === 0) return;

                const mean = jStat.mean(data);
                const variance = jStat.variance(data, true);
                const skewness = jStat.skewness(data);
                const kurtosis = jStat.kurtosis(data);
                const isInteger = data.every(x => Number.isInteger(x) && x >= 0);
                const max = jStat.max(data);
                const median = jStat.median(data);

                if (isInteger) {
                    hints.push("Data are non-negative integers → Discrete models (Poisson, Negative Binomial) are appropriate.");
                    if (variance > mean) {
                        hints.push(`Variance (${variance.toFixed(2)}) > Mean (${mean.toFixed(2)}) → Overdispersion detected. Suggestions: Negative Binomial.`);
                    } else if (variance < mean) {
                        hints.push(`Variance (${variance.toFixed(2)}) < Mean (${mean.toFixed(2)}) → Underdispersion detected. Suggestions: Binomial.`);
                    }
                }

                if (skewness > 0.5) {
                    hints.push(`Positive skewness (${skewness.toFixed(2)}) → Data leans right. Suggestions: Gamma, Lognormal, Weibull.`);
                }

                if (kurtosis > 1 || (max / median > 5)) {
                    hints.push("Possible heavy tail detected → Suggestions: Pareto, GEV, Lognormal.");
                }

                if (hints.length > 0) {
                    insightsPanel.style.display = 'block';
                    hints.forEach(h => {
                        const li = document.createElement('li');
                        li.textContent = h;
                        insightsList.appendChild(li);
                    });
                } else {
                    insightsPanel.style.display = 'none';
                }
            };
        });
    </script>
</body>

</html>